# 数据结构与算法：python描述 [北京大学出版社]

# 目录

# 1 绪论

# 2 抽象数据类型和python类

# 3 线性表

# 4 字符串

# 5 栈和队列

# 6 二叉树和树

# 7 图

# 8 字典和集合

# 9 排序

# 1 绪论

## 1.3 算法和算法分析

算法的性质:

- 有穷性:算法由有限多条命令或语句构成
- 能行性:算法中的命令必须是可执行的
- 确定性:对于给定的输入,通过一系列操作,产生问题的解
- 终止性:算法要么求出解,要么支出问题无解
- 输入/输出:有明确定义的输入和输出

算法的描述:

- 自然语言
- 伪代码
- 类似某种编程语言的形式描述算法

算法设计与分析:算法设计中一些常见的通用想法可以成为算法设计模式.常见模式为:

- 枚举法:枚举问题的各种可能,从中选出有用信息或者问题的解.利用计算机速度优势,结局简单问题十分有效
- 贪心法:根据问题尽可能做出部分的解,并基于部分解逐步扩充到完整解
- 分治法:把问题分解为相对简单的子问题,分别求解.最后组合子问题解得到原问题的解
- 回溯法(搜索法):分步骤求解问题.如果一个方向无法得到答案,就后退到前一步,在选另一条路走
- 动态规划法:一些复杂情况下,问题很难直接求解.因此需要在前面的步骤中积累信息.后续步骤根据已知信息,动态选择已知的最好求解路径
- 分支限界法:可以看做搜索的一种改良方法.如果搜索过程中可以得到一些信息,从而确定某种可能的选择实际并不真正有用,就可以及早删除该路径

### 1.3.2算法的代价及其度量

算法常见时间复杂度O(1),O(n),O(nlogn),O(n**2),O(n**3),O(2**n)

求斐波那契第n位值:

```python
def fib(n):
    if n<2:
        return 1
    else:
        return fib(n-1)+fib(n-2)
# 这里的时间复杂度大致为为Fn-1何Fn-2之和,也就是按n的指数增长,当n较大时,计算需要很长时间

def fib(n):
    f1=f2=1
    for i in range(1,n):
        f1,f2=f2,f2+f1
    return f2
# 这里是执行n-1次,时间复杂度是线性关系,非常快
```

**python中递归有深度限制,而且递归很慢**

有的算法占用时间少,有的算法占用空间少

### 1.3.3 算法分析(基本循环程序)

只考虑算法的时间复杂度,考虑最基本的循环程序,其中只有有序组合,条件分支和循环结构.分析这种算法只需几条基本计算规则:

1. 基本操作,认为时间复杂度为O(1).如果是函数调用,应该将其时间复杂度带入,参与整体时间复杂度的计算
2. 加法规则(顺序复合).如果算法(或所考虑的算法片段)是两个部分(或多个部分)的顺序复合,其时间复杂度是两部分(或多部分之和)`T(n)=T1(n)+T2(n)=O(T1(n))+O(T2(n))=O(max(T1(n),T2(n)))`最后取时间复杂度最大的一个
3. 乘法规则(循环结构).如果算法(或者所考虑的算法片段)是一个循环.循环体将执行T1(n)次,每次执行需要T2(n)时间,那么时间复杂度:`T(n)=T1(n)*T2(n)=O(T1(n))*O(T2(n))=O(T1(n)*T2(n))`
4. 取最大规则.如果算法是条件分支,应该选择最大那个`T(n)=O(max(T1(n),T2(n)))`

### 1.3.4 python程序计算代价(复杂度)

**时间开销**,python中很多基本操作不是常量时间.

- 基本算术是常量,逻辑运算也是常量
- 组合对象的操作有些事常量时间,有些不是.

  - 复制和切片是O(n)
  - list和tuple的元素访问和复制,是常量时间
  - dict操作比较复杂

- 字符串中许多操作不是常量时间

- 创建对象也要付出空间和时间.通常是线性时间,依赖于元素个数
- 构造西结构,例如list,set等.构造新的空结构是常量时间,而构造包含n个元素的结构,至少需要O(n)时间
- 一些list操作的效率:元素访问和修改时常量时间操作,但是一般的加入和删除元素操作都是O(n)时间操作
- 字典dict操作效率:主要操作是添加键值对.最坏情况是O(n),单平均是O(1)

```python
import time
def test1(n):
    lst=[]
    for i in range(n*10000):
        lst=lst+[i]
    return lst

def test2(n):
    lst=[]
    for i in range(n*10000):
        lst.append(i)
    return lst

def test3(n):
    return [i for i in range(n*10000)]

def test4(n):
    return list(range(10000))

start=time.time()
test1(10)
print('test1:{time}'.format(time=time.time()-start))

start=time.time()
test2(10)
print('test2:{time}'.format(time=time.time()-start))

start=time.time()
test3(10)
print('test3:{time}'.format(time=time.time()-start))

start=time.time()
test4(10)
print('test4:{time}'.format(time=time.time()-start))

mering:$ time python test2
test1:18.2594280243
test2:0.00935983657837
test3:0.00486898422241
test4:0.00018310546875

real    0m18.300s
user    0m18.127s
sys    0m0.138s
```

## 1.4 数据结构

越复杂的数据结构处理起来也就可能越复杂

### 1.4.1 数据结构及其分类

- 集合结构:元素之间没有需要关注的明确关系,也就是关系R是空集.这样的数据结构也就是其元素的集合,只是把一组数据元素包装成为一个整体
- 序列结构:其数据元素之间有明确的先后关系(顺序关系).存在一个排位在最前的元素,除了最后的元素外,每一个元素都有一个后继元素.例如环形结构,p型结构
- 层次结构:其数据元素分属于一些不同的层次,一个上层元素可以关联着一个或多个下层元素,关系R形成一种明确的层次性,只从上层到下层(通常也允许跨层次)
- 树形结构:层次结构中最简单的一种关系是树形结构,只有一个最上层元素,称为根元素.
- 图结构:数据元素之间可以有任意复杂的相互关系.

**实际上所有数据结构都可以看作是特殊的图结构**

# 2 抽象数据结构和Python类
